import React, { useState, useEffect, useCallback } from 'react';
import { Modal, Form, Input, Select, InputNumber, Button, message } from 'antd';
import styled from 'styled-components';
import axios from 'axios';
import { issuesApi } from '../services/api';
import { useStore } from '../store/useStore';
import { VoiceDescriptionButton } from './VoiceDescription/VoiceDescriptionButton';
import { DuplicateAlert } from './DuplicateDetection/DuplicateAlert';

const { TextArea } = Input;

const DescriptionWrapper = styled.div`
  position: relative;
  
  .voice-button-wrapper {
    position: absolute;
    top: -40px;
    right: 0;
    z-index: 1;
  }
`;

interface CreateIssueModalProps {
  open: boolean;
  onClose: () => void;
  onSuccess: () => void;
  defaultType?: string;
}

export const CreateIssueModal: React.FC<CreateIssueModalProps> = ({ open, onClose, onSuccess, defaultType = 'story' }) => {
  const [form] = Form.useForm();
  const [loading, setLoading] = useState(false);
  const [selectedType, setSelectedType] = useState<string>(defaultType);
  const { currentProject, currentUser } = useStore();
  
  // Duplicate detection state
  const [duplicates, setDuplicates] = useState<any[]>([]);
  const [duplicateConfidence, setDuplicateConfidence] = useState(0);
  const [duplicateSuggestion, setDuplicateSuggestion] = useState('');
  const [checkingDuplicates, setCheckingDuplicates] = useState(false);
  const [showDuplicates, setShowDuplicates] = useState(false);

  // Debounced duplicate checking
  const checkForDuplicates = useCallback(
    async (summary: string, description: string) => {
      if (!summary || summary.length < 3 || !currentProject) {
        setShowDuplicates(false);
        return;
      }

      setCheckingDuplicates(true);
      try {
        const response = await axios.post('http://localhost:8500/api/ai-description/check-duplicates', {
          summary,
          description: description || '',
          projectId: currentProject.id,
          issueType: selectedType
        });

        if (response.data.success && response.data.hasDuplicates) {
          setDuplicates(response.data.duplicates);
          setDuplicateConfidence(response.data.confidence);
          setDuplicateSuggestion(response.data.suggestion);
          setShowDuplicates(true);
        } else {
          setShowDuplicates(false);
        }
      } catch (error) {
        console.error('Error checking duplicates:', error);
        setShowDuplicates(false);
      } finally {
        setCheckingDuplicates(false);
      }
    },
    [currentProject, selectedType]
  );

  // Debounce timer
  useEffect(() => {
    const summary = form.getFieldValue('summary');
    const description = form.getFieldValue('description');

    if (!summary) {
      setShowDuplicates(false);
      return;
    }

    const timer = setTimeout(() => {
      checkForDuplicates(summary, description);
    }, 500); // 500ms debounce

    return () => clearTimeout(timer);
  }, [form.getFieldValue('summary'), form.getFieldValue('description'), checkForDuplicates]);

  const handleSubmit = async (values: any) => {
    if (!currentProject || !currentUser) {
      message.error('Project or user not found');
      return;
    }

    setLoading(true);
    try {
      // Create issue data based on type
      // Note: Backend will generate the issue key automatically
      const baseData = {
        summary: values.summary,
        description: values.description || '',
        type: values.type,
        status: 'todo',
        priority: values.priority,
        projectId: currentProject.id,
        reporterId: currentUser.id,
        assigneeId: null,
        labels: values.labels || [],
        components: [],
        fixVersions: [],
      };

      // Add type-specific fields
      const issueData: any = { ...baseData };
      
      if (values.type === 'story' || values.type === 'task') {
        issueData.storyPoints = values.storyPoints || null;
      }
      
      if (values.type === 'bug') {
        issueData.environment = values.environment || null;
      }
      
      if (values.type === 'epic') {
        issueData.epicName = values.epicName || values.summary;
      }

      // Create issue via API
      const response = await issuesApi.create(issueData);
      
      // Use the key from the response (backend generated)
      const createdKey = response.data?.key || 'Issue';
      message.success(`${createdKey} created successfully!`);
      form.resetFields();
      setSelectedType('story');
      setShowDuplicates(false);
      setDuplicates([]);
      onSuccess();
      onClose();
    } catch (error: any) {
      console.error('Failed to create issue:', error);
      message.error(error.response?.data?.error || 'Failed to create issue');
    } finally {
      setLoading(false);
    }
  };

  // Render fields based on issue type
  const renderTypeSpecificFields = () => {
    switch (selectedType) {
      case 'epic':
        return (
          <>
            <Form.Item
              name="epicName"
              label="Epic Name"
              rules={[{ required: true, message: 'Please enter epic name' }]}
            >
              <Input placeholder="Enter epic name" />
            </Form.Item>
            <Form.Item
              name="epicColor"
              label="Epic Color"
            >
              <Select placeholder="Select color">
                <Select.Option value="blue">Blue</Select.Option>
                <Select.Option value="green">Green</Select.Option>
                <Select.Option value="purple">Purple</Select.Option>
                <Select.Option value="red">Red</Select.Option>
              </Select>
            </Form.Item>
          </>
        );
      
      case 'story':
        return (
          <Form.Item
            name="storyPoints"
            label="Story Points"
          >
            <InputNumber min={1} max={100} placeholder="Estimate" style={{ width: '100%' }} />
          </Form.Item>
        );
      
      case 'task':
        return (
          <Form.Item
            name="storyPoints"
            label="Story Points"
          >
            <InputNumber min={1} max={100} placeholder="Estimate" style={{ width: '100%' }} />
          </Form.Item>
        );
      
      case 'bug':
        return (
          <>
            <Form.Item
              name="environment"
              label="Environment"
            >
              <Input placeholder="e.g., Production, Staging" />
            </Form.Item>
            <Form.Item
              name="severity"
              label="Severity"
            >
              <Select placeholder="Select severity">
                <Select.Option value="critical">Critical</Select.Option>
                <Select.Option value="major">Major</Select.Option>
                <Select.Option value="minor">Minor</Select.Option>
                <Select.Option value="trivial">Trivial</Select.Option>
              </Select>
            </Form.Item>
          </>
        );
      
      case 'subtask':
        return (
          <Form.Item
            name="parentIssue"
            label="Parent Issue"
            rules={[{ required: true, message: 'Please select parent issue' }]}
          >
            <Select placeholder="Select parent issue">
              <Select.Option value="AYP-1">AYP-1</Select.Option>
              <Select.Option value="AYP-2">AYP-2</Select.Option>
            </Select>

  if (!summary) {
    setShowDuplicates(false);
    return;
  }

  const timer = setTimeout(() => {
    checkForDuplicates(summary, description);
  }, 500); // 500ms debounce

  return () => clearTimeout(timer);
}, [form.getFieldValue('summary'), form.getFieldValue('description'), checkForDuplicates]);

const handleSubmit = async (values: any) => {
  if (!currentProject || !currentUser) {
    message.error('Project or user not found');
    return;
  }

  setLoading(true);
  try {
    // Create issue data based on type
    // Note: Backend will generate the issue key automatically
    const baseData = {
      summary: values.summary,
      description: values.description || '',
      type: values.type,
      status: 'todo',
      priority: values.priority,
      projectId: currentProject.id,
      reporterId: currentUser.id,
      assigneeId: null,
      labels: values.labels || [],
      components: [],
      fixVersions: [],
    };

    // Add type-specific fields
    const issueData: any = { ...baseData };
    
    if (values.type === 'story' || values.type === 'task') {
      issueData.storyPoints = values.storyPoints || null;
    }
    
    if (values.type === 'bug') {
      issueData.environment = values.environment || null;
    }
    
    if (values.type === 'epic') {
      issueData.epicName = values.epicName || values.summary;
    }

    // Create issue via API
    const response = await issuesApi.create(issueData);
    
    // Use the key from the response (backend generated)
    const createdKey = response.data?.key || 'Issue';
    message.success(`${createdKey} created successfully!`);
    form.resetFields();
    setSelectedType('story');
    setShowDuplicates(false);
    setDuplicates([]);
    onSuccess();
    onClose();
  } catch (error: any) {
    console.error('Failed to create issue:', error);
    message.error(error.response?.data?.error || 'Failed to create issue');
  } finally {
    setLoading(false);
  }
};

// Render fields based on issue type
const renderTypeSpecificFields = () => {
  switch (selectedType) {
    case 'epic':
      return (
        <>
          <Form.Item
            name="epicName"
            label="Epic Name"
            rules={[{ required: true, message: 'Please enter epic name' }]}
          >
            <Input placeholder="Enter epic name" />
          </Form.Item>
          <Form.Item
            name="epicColor"
            label="Epic Color"
          >
            <Select placeholder="Select color">
              <Select.Option value="blue">Blue</Select.Option>
              <Select.Option value="green">Green</Select.Option>
              <Select.Option value="purple">Purple</Select.Option>
              <Select.Option value="red">Red</Select.Option>
            </Select>
          </Form.Item>
        </>
      );
    
    case 'story':
      return (
        <Form.Item
          name="storyPoints"
          label="Story Points"
        >
          <InputNumber min={1} max={100} placeholder="Estimate" style={{ width: '100%' }} />
        </Form.Item>
      );
    
    case 'task':
      return (
        <Form.Item
          name="storyPoints"
          label="Story Points"
        >
          <InputNumber min={1} max={100} placeholder="Estimate" style={{ width: '100%' }} />
        </Form.Item>
      );
    
    case 'bug':
      return (
        <>
          <Form.Item
            name="environment"
            label="Environment"
          >
            <Input placeholder="e.g., Production, Staging" />
          </Form.Item>
          <Form.Item
            name="severity"
            label="Severity"
          >
            <Select placeholder="Select severity">
              <Select.Option value="critical">Critical</Select.Option>
              <Select.Option value="major">Major</Select.Option>
              <Select.Option value="minor">Minor</Select.Option>
              <Select.Option value="trivial">Trivial</Select.Option>
            </Select>
          </Form.Item>
        </>
      );
    
    case 'subtask':
      return (
        <Form.Item
          name="parentIssue"
          label="Parent Issue"
          rules={[{ required: true, message: 'Please select parent issue' }]}
        >
          <Select placeholder="Select parent issue">
            <Select.Option value="AYP-1">AYP-1</Select.Option>
            <Select.Option value="AYP-2">AYP-2</Select.Option>
          </Select>
        </Form.Item>
      );
    
    default:
      return null;
  }
};

const handleViewIssue = (issueKey: string) => {
  window.open(`/issue/${issueKey}`, '_blank');
};

const handleDismissDuplicates = () => {
  setShowDuplicates(false);
};

return (
  <Modal
    title={`Create Issue - ${currentProject?.name || 'Project'}`}
    open={open}
    onCancel={onClose}
    footer={null}
    width={600}
  >
    <Form
      form={form}
      layout="vertical"
      onFinish={handleSubmit}
      initialValues={{ type: 'story', priority: 'medium' }}
      onCancel={onClose}
      footer={null}
      width={600}
    >
      <Form
        form={form}
        layout="vertical"
        onFinish={handleSubmit}
        initialValues={{ type: 'story', priority: 'medium' }}
      >
        <Form.Item
          name="type"
          label="Issue Type"
          rules={[{ required: true, message: 'Please select issue type' }]}
        >
          <Select onChange={(value) => setSelectedType(value)}>
            <Select.Option value="epic">ğŸ¯ Epic</Select.Option>
            <Select.Option value="story">ğŸ“– Story</Select.Option>
            <Select.Option value="task">âœ… Task</Select.Option>
            <Select.Option value="bug">ğŸ› Bug</Select.Option>
            <Select.Option value="subtask">ğŸ“ Subtask</Select.Option>
          </Select>
        </Form.Item>

        <Form.Item
          name="summary"
          label="Summary"
          rules={[{ required: true, message: 'Please enter summary' }]}
        >
          <Input 
            placeholder="What needs to be done?" 
            onChange={(e) => {
              // Trigger form field change to activate duplicate checking
              form.setFieldsValue({ summary: e.target.value });
            }}
          />
        </Form.Item>

        {/* Duplicate Detection Alert */}
        {showDuplicates && duplicates.length > 0 && (
          <DuplicateAlert
            duplicates={duplicates}
            confidence={duplicateConfidence}
            suggestion={duplicateSuggestion}
            onDismiss={handleDismissDuplicates}
            onViewIssue={handleViewIssue}
          />
        )}

        <Form.Item
          name="description"
          label={
            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', width: '100%' }}>
              <span>Description</span>
              <VoiceDescriptionButton
                issueType={selectedType as any}
                issueSummary={form.getFieldValue('summary')}
                projectId={currentProject?.id}
                onTextGenerated={(text) => form.setFieldsValue({ description: text })}
              />
            </div>
          }
        >
          <TextArea rows={4} placeholder="Add a description..." />
        </Form.Item>

        <Form.Item
          name="priority"
          label="Priority"
          rules={[{ required: true, message: 'Please select priority' }]}
        >
          <Select>
            <Select.Option value="highest">ğŸ”´ Highest</Select.Option>
            <Select.Option value="high">ğŸŸ  High</Select.Option>
            <Select.Option value="medium">ğŸŸ¡ Medium</Select.Option>
            <Select.Option value="low">ğŸŸ¢ Low</Select.Option>
            <Select.Option value="lowest">ğŸ”µ Lowest</Select.Option>
          </Select>
        </Form.Item>

        {renderTypeSpecificFields()}

        <Form.Item
          name="labels"
          label="Labels"
        >
          <Select mode="tags" placeholder="Add labels">
            <Select.Option value="frontend">frontend</Select.Option>
            <Select.Option value="backend">backend</Select.Option>
            <Select.Option value="bug">bug</Select.Option>
            <Select.Option value="feature">feature</Select.Option>
          </Select>
        </Form.Item>

        <Form.Item>
          <Button type="primary" htmlType="submit" loading={loading} block size="large">
            Create Issue
          </Button>
        </Form.Item>
      </Form>
    </Modal>
  );
};
